unit FiguresUnit;

interface

uses
  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ExtCtrls,
  Menus, ActnList, GraphMath, ScaleUnit, LCLType, LCLIntf, LCL, StdCtrls, Grids,
   Buttons, Math, Spin, FPCanvas, TypInfo,  Windows, Laz2_DOM, laz2_XMLRead, laz2_XMLWrite;

type

  TFigureClass    = class  of TFigure;
  tempPointsArray = array[0..3] of TPoint;
  PolygonPointsArray = array of TPoint;
  StringArray = array of string;

  TFigure = class
    Selected: boolean;
    Index: Integer;
    CL:TClass;
    Region: HRGN;
    Points: array of TFloatPoint;
    class procedure SaveFile(FileName: String);
    procedure Draw(ACanvas: TCanvas); virtual; abstract;
    procedure SetRegion; Virtual; abstract;
    procedure DrawSelection(AFigure: TFigure; Canvas: TCanvas; Width: integer);  virtual;
    function SaveFigure(ADoc: TXMLDocument): TDOMNode; virtual; abstract;
    class function LoadFile(FileName: String): Boolean;
  end;

  TLittleFigure = class(TFigure)
    PenColor: TColor;
    PenStyle: TPenStyle;
    Width: integer;
    procedure Draw(ACanvas: TCanvas); override;
    procedure SetRegion; override;
  end;

  TBigFigure = class(TLittleFigure)
    BrushColor: TColor;
    BrushStyle: TBrushStyle;
    RoundingRadiusX: integer;
    RoundingRadiusY: integer;
    procedure Draw(ACanvas: TCanvas); override;
    procedure SetRegion; override;
  end;

  TPolyLine = class(TLittleFigure)
  private
    W:integer;
    PS: TPenStyle;
    PC: TColor;
  public
    procedure Draw(ACanvas: TCanvas); override;
    procedure SetRegion; override;
    function SaveFigure(ADoc: TXMLDocument): TDOMNode; override;
  end;

  TLine = class(TLittleFigure)
  private
    W:integer;
    PS: TPenStyle;
    PC: TColor;
  public
    procedure Draw(ACanvas: TCanvas); override;
    procedure SetRegion; override;
    function SaveFigure(ADoc: TXMLDocument): TDOMNode; override;
  end;

  TEllipse = class(TBigFigure)
  private
    BC: Tcolor;
    BS: TBrushStyle;
    W:integer;
    PS: TPenStyle;
    PC: TColor;
  public
    procedure Draw(ACanvas: TCanvas); override;
    procedure SetRegion; override;
    function SaveFigure(ADoc: TXMLDocument): TDOMNode; override;
  end;

  TRectangle = class(TBigFigure)
  private
    BC: Tcolor;
    BS: TBrushStyle;
    W:integer;
    PS: TPenStyle;
    PC: TColor;
  public
    procedure Draw(ACanvas: TCanvas); override;
    procedure SetRegion; override;
    function SaveFigure(ADoc: TXMLDocument): TDOMNode; override;
  end;

  TRectangleMagnifier = class(TLittleFigure)
    BrushStyle: TBrushStyle;
    BrushColor: TColor;
    procedure Draw(ACanvas: TCanvas); override;
    function SaveFigure(ADoc: TXMLDocument): TDOMNode; override;
  end;

  TRoundedRectangle = class(TBigFigure)
  private
   BC: Tcolor;
    BS: TBrushStyle;
    W:integer;
    PS: TPenStyle;
    PC: TColor;
    RX:integer;
    RY:integer;
  public
    procedure Draw(ACanvas: TCanvas); override;
    procedure SetRegion; override;
    function SaveFigure(ADoc: TXMLDocument): TDOMNode; override;
  end;

  procedure LineRegion(p1,p2:TPoint;var tempPoints: array of TPoint;Width:integer);
  function FiguresToXML():TXMLDocument;

var
  Figures: array of TFigure;
  layer: array of Tfigure;

  CtrlButtonState:Boolean=false;
  IsSaved: boolean = True;

implementation

                        {Save}
class procedure TFigure.SaveFile(FileName: String);
  var Doc:TXMLDocument;
begin
  if (Copy(FileName, Length(FileName) - 3, 4) <> '.xml') then
    Exit;
  try
    Doc:= FiguresToXML();
    WriteXML(Doc, FileName);
    //Saved:= Current;
  finally
    Doc.Free;
  end;
end;

function FiguresToXML(): TXMLDocument;
var
  Doc: TXMLDocument;
  FiguresNode: TDOMNode;
  i: Integer;
begin
  Doc:= TXMLDocument.Create;
  FiguresNode:= Doc.CreateElement('Figures');
  Doc.AppendChild(FiguresNode);
  FiguresNode:= Doc.DocumentElement;
  for i:= 0 to High(Figures) do
  if Figures[i].CL<>TRectangleMagnifier then
    FiguresNode.AppendChild(Figures[i].SaveFigure(Doc));
  Result:= Doc;
end;

function TPolyline.SaveFigure(ADoc: TXMLDocument): TDOMNode;
var
  PNode: TDOMNode;
   i: Integer;
begin
  Result:= ADoc.CreateElement('TPolyline');
  TDOMElement(result).SetAttribute('Width', IntToStr(W));
  TDOMElement(result).SetAttribute('PenStyle',  GetEnumName(TypeInfo(PS), Integer(PS)));
  TDOMElement(result).SetAttribute('PenColor', IntToStr(PC));
  for i:= 0 to High(Points) do begin
    PNode:= ADoc.CreateElement('point');
    TDOMElement(PNode).SetAttribute('x', FloatToStr(Points[i].X));
    TDOMElement(PNode).SetAttribute('y', FloatToStr(Points[i].Y));
    Result.AppendChild(PNode);
  end;
end;

function Tline.SaveFigure(ADoc: TXMLDocument): TDOMNode;
var
  PNode: TDOMNode;
  i: Integer;
begin
  Result:= ADoc.CreateElement('Tline');
  TDOMElement(result).SetAttribute('Width', IntToStr(W));
  TDOMElement(result).SetAttribute('PenStyle',  GetEnumName(TypeInfo(PS), Integer(PS)));
  TDOMElement(result).SetAttribute('PenColor', IntToStr(PC));
  for i:= 0 to High(Points) do begin
    PNode:= ADoc.CreateElement('point');
    TDOMElement(PNode).SetAttribute('x', FloatToStr(Points[i].X));
    TDOMElement(PNode).SetAttribute('y', FloatToStr(Points[i].Y));
    Result.AppendChild(PNode);
  end;
end;

function TRectangle.SaveFigure(ADoc: TXMLDocument): TDOMNode;
var
  PNode: TDOMNode;
  i: Integer;
begin
  Result:= ADoc.CreateElement('TRectangle');
  TDOMElement(result).SetAttribute('Width', IntToStr(W));
  TDOMElement(result).SetAttribute('PenStyle',  GetEnumName(TypeInfo(PS), Integer(PS)));
  TDOMElement(result).SetAttribute('PenColor', IntToStr(PC));
  TDOMElement(result).SetAttribute('BrushStyle',  GetEnumName(TypeInfo(BS), Integer(BS)));
  TDOMElement(result).SetAttribute('BrushColor', IntToStr(BC));

  for i:= 0 to High(Points) do begin
    PNode:= ADoc.CreateElement('point');
    TDOMElement(PNode).SetAttribute('x', FloatToStr(Points[i].X));
    TDOMElement(PNode).SetAttribute('y', FloatToStr(Points[i].Y));
    Result.AppendChild(PNode);
  end;
end;

function TEllipse.SaveFigure(ADoc: TXMLDocument): TDOMNode;
var
  PNode: TDOMNode;
  i: Integer;
begin
  Result:= ADoc.CreateElement('TEllipse');
  TDOMElement(result).SetAttribute('Width', IntToStr(W));
  TDOMElement(result).SetAttribute('PenStyle',  GetEnumName(TypeInfo(PS), Integer(PS)));
  TDOMElement(result).SetAttribute('PenColor', IntToStr(PC));
  TDOMElement(result).SetAttribute('BrushStyle',  GetEnumName(TypeInfo(BS), Integer(BS)));
  TDOMElement(result).SetAttribute('BrushColor', IntToStr(BC));
  for i:= 0 to High(Points) do begin
    PNode:= ADoc.CreateElement('point');
    TDOMElement(PNode).SetAttribute('x', FloatToStr(Points[i].X));
    TDOMElement(PNode).SetAttribute('y', FloatToStr(Points[i].Y));
    Result.AppendChild(PNode);
  end;
end;

function TRoundedRectangle.SaveFigure(ADoc: TXMLDocument): TDOMNode;
var
  PNode: TDOMNode;
  var i:Int64;
begin
  Result:= ADoc.CreateElement('TRoundRect');
  TDOMElement(result).SetAttribute('Width', IntToStr(W));
  TDOMElement(result).SetAttribute('PenStyle',  GetEnumName(TypeInfo(PS), Integer(PS)));
  TDOMElement(result).SetAttribute('PenColor', IntToStr(PC));
  TDOMElement(result).SetAttribute('BrushStyle',  GetEnumName(TypeInfo(BS), Integer(BS)));
  TDOMElement(result).SetAttribute('BrushColor', IntToStr(BC));
  TDOMElement(result).SetAttribute('RadiusX', IntToStr(RX));
  TDOMElement(result).SetAttribute('RadiusY', IntToStr(RY));
  for i:= 0 to High(Points) do begin
    PNode:= ADoc.CreateElement('point');
    TDOMElement(PNode).SetAttribute('x', FloatToStr(Points[i].X));
    TDOMElement(PNode).SetAttribute('y', FloatToStr(Points[i].Y));
    Result.AppendChild(PNode);
  end;
end;
function TRectangleMagnifier.SaveFigure(ADoc: TXMLDocument): TDOMNode;
begin
  Result:= ADoc.CreateElement('');
end;

procedure TLittleFigure.Draw(ACanvas: TCanvas);
begin
  ACanvas.Pen.Color := PenColor;
  ACanvas.Pen.Style := PenStyle;
  ACanvas.Pen.Width := Width;
end;

procedure TBigFigure.Draw(ACanvas: TCanvas);
begin
  inherited;
  ACanvas.Brush.Style := BrushStyle;
  ACanvas.Brush.Color := BrushColor;
end;

procedure TLine.Draw(ACanvas: TCanvas);
begin
  inherited;
  ACanvas.Line(WorldToScreen(Points[0]).x, WorldToScreen(Points[0]).Y, WorldToScreen(Points[1]).x, WorldToScreen(Points[1]).Y);
end;

procedure TPolyLine.Draw(ACanvas: TCanvas);
var
  i: integer;
begin
  inherited;
  for i := 1 to high(Points) - 1 do
    ACanvas.Line(WorldToScreen(Points[i]), WorldToScreen(Points[i + 1]));
end;

procedure TEllipse.Draw(ACanvas: TCanvas);
begin
  inherited;
  ACanvas.Ellipse(WorldToScreen(Points[0]).x, WorldToScreen(Points[0]).Y, WorldToScreen(Points[1]).x, WorldToScreen(Points[1]).Y);
end;

procedure TRectangle.Draw(ACanvas: TCanvas);
begin
  inherited;
  ACanvas.Rectangle(WorldToScreen(Points[0]).x, WorldToScreen(Points[0]).Y, WorldToScreen(Points[1]).x, WorldToScreen(Points[1]).Y);
end;

procedure TRectangleMagnifier.Draw(ACanvas: TCanvas);
begin
  inherited;
  ACanvas.Frame(WorldToScreen(Points[0]).x, WorldToScreen(Points[0]).Y, WorldToScreen(Points[1]).x, WorldToScreen(Points[1]).Y);
end;

procedure TRoundedRectangle.Draw(ACanvas: TCanvas);
begin
  inherited;
  ACanvas.RoundRect(WorldToScreen(Points[0]).x, WorldToScreen(Points[0]).Y, WorldToScreen(Points[1]).x, WorldToScreen(Points[1]).Y,
    RoundingRadiusX, RoundingRadiusY);
end;

procedure SetOffset(APoint: TFloatPoint);
begin
  Offset := APoint;
end;

procedure TBigFigure.SetRegion;
begin
end;

procedure TLittleFigure.SetRegion;
begin
end;

procedure TRectangle.SetRegion;
var
  RegionRect: TRect;
begin
  RegionRect.TopLeft := WorldToScreen(Points[0]);
  RegionRect.BottomRight := WorldToScreen(Points[1]);
  Region := CreateRectRgn(RegionRect.Left,RegionRect.Top,RegionRect.Right,RegionRect.Bottom);
end;

procedure TEllipse.SetRegion;
var
  RegionRect: TRect;
begin
  RegionRect.TopLeft := WorldToScreen(Points[0]);
  RegionRect.BottomRight := WorldToScreen(Points[1]);
  Region := CreateEllipticRgn (RegionRect.Left,RegionRect.Top,RegionRect.Right,RegionRect.Bottom);
end;

procedure TRoundedRectangle.SetRegion;
var
  RegionRect: TRect;
begin
  RegionRect.TopLeft := WorldToScreen(Points[0]);
  RegionRect.BottomRight := WorldToScreen(Points[1]);
  Region := CreateRoundRectRgn (RegionRect.Left,RegionRect.Top,RegionRect.Right,
    RegionRect.Bottom,RoundingRadiusX,RoundingRadiusY);
end;

procedure TLine.SetRegion;
var
  RegionPoints: array[0..3] of TPoint;
  p1,p2: TPoint;
begin
  p1 := WorldToScreen(Points[0]);
  p2 := WorldToScreen(Points[1]);
  LineRegion(p1,p2,RegionPoints,Width);
  Region := CreatePolygonRgn(RegionPoints,3,2);
end;

procedure TPolyline.SetRegion;
var
  RegionPoints: array[0..3] of TPoint;
  p1,p2: TPoint;
  curRgn: HRGN;
  i: integer;
begin
  for i := 0 to high(Points)-1 do
  begin
    p1 := WorldToScreen(Points[i]);
    p2 := WorldToScreen(Points[i+1]);
    LineRegion(p1,p2,RegionPoints,Width);
    if (i=low(Points)) then Region := CreatePolygonRgn (RegionPoints,3,2);
    curRgn := CreatePolygonRgn (RegionPoints,3,2);
    CombineRgn (Region,Region,curRgn,RGN_OR);
    DeleteObject(curRgn);
  end;
end;

procedure TFigure.DrawSelection(AFigure: TFigure; Canvas: TCanvas; Width: integer);
var
  Point1, Point2, a:TFloatPoint;
  i: integer;
  max,min: TFloatPoint;
begin
  If length(AFigure.Points) = 2 then begin
    Point1.X := AFigure.Points[0].X;
    Point1.Y := AFigure.Points[0].Y;
    Point2.X := AFigure.Points[1].X;
    Point2.Y := AFigure.Points[1].Y;
    if (Point1.X>Point2.X) then
    begin
      a.X:=Point1.X;
      Point1.X:=Point2.X;
      Point2.X:=a.X;
    end;
    if (Point1.Y>Point2.Y) then
    begin
      a.Y:=Point1.Y;
      Point1.Y:=Point2.Y;
      Point2.Y:=a.Y;
    end;
    Canvas.Pen.Color := clBlack;
    Canvas.Pen.Width := 1;
    Canvas.Pen.Style := psDash;
    Canvas.Frame(WorldToScreen(Point1).x - 5 - Width div 2,WorldToScreen(Point1).y - 5 - Width div 2,
                 WorldToScreen(Point2).x + 5 + Width div 2,WorldToScreen(Point2).y + 5 - Width div 2);

  end else begin
    max := AFigure.Points[0];
    min := AFigure.Points[0];
    for i:=0 to length(AFigure.Points) - 1 do begin
      if AFigure.Points[i].X > max.x then max.x := AFigure.Points[i].X;
      if AFigure.Points[i].Y > max.y then max.y := AFigure.Points[i].y;
      if AFigure.Points[i].X < min.x then min.x := AFigure.Points[i].X;
      if AFigure.Points[i].Y < min.y then min.y := AFigure.Points[i].Y;
    end;

    Canvas.Pen.Color := clBlack;
    Canvas.Pen.Width := 1;
    Canvas.Pen.Style := psDash;
    Canvas.Frame(WorldToScreen(min).x - 5 - Width div 2,WorldToScreen(min).y - 5 - Width div 2,
                 WorldToScreen(max).x + 5 + Width div 2,WorldToScreen(max).y + 5 + Width div 2);
  end;
end;

procedure LineRegion(p1,p2:TPoint;var tempPoints: array of TPoint;Width:integer);
begin
  if (abs(p2.x-p1.x)>45) then
  begin
    tempPoints[0].x := p1.x-Width div 2;
    tempPoints[0].y := p1.y-5-Width;
    tempPoints[1].x := p2.x+Width div 2;
    tempPoints[1].y := p2.y-5-Width;
    tempPoints[2].x := p2.x+Width div 2;
    tempPoints[2].y := p2.y+5+Width;
    tempPoints[3].x := p1.x-Width div 2;
    tempPoints[3].y := p1.y+5+Width;
  end else
  begin
    tempPoints[0].x := p1.x-5-Width;
    tempPoints[0].y := p1.y-Width div 2;
    tempPoints[1].x := p2.x-5-Width;
    tempPoints[1].y := p2.y+Width div 2;
    tempPoints[2].x := p2.x+5+Width;
    tempPoints[2].y := p2.y+Width div 2;
    tempPoints[3].x := p1.x+5+Width;
    tempPoints[3].y := p1.y-Width div 2;
  end;
end;

begin
end.
